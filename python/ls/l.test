l
=

	>>> import l
	>>> from path import cd, pwd, path
	>>> cd(l.__file__)
	True

If that worked, then we can test for these files:

	>>> this_python_file = path('l.py')
	>>> this_test_file = path('l.test')
	>>> this_tests_file = path('l.tests')

These files should exist in this directory
	>>> these_files = this_python_file, this_test_file, this_tests_file
	>>> [ f.isfile() for f in these_files ]
	[True, True, True]

as_paths
--------

This method turns its arguments into a list of paths

	>>> l.as_paths([ 'fred', '~', path('.') ])
	[<path 'fred'>, <path '/Users/jab'>, <path '.'>]

get_dirs
--------

get_dirs converts a list of strings to a list of paths
	if they exist

	>>> print l.get_dirs([this_test_file, '..', 'No such path'])
	[<path '.'>, <path '..'>]

It expands paths if possible
	>>> print l.get_dirs([ '~', '$MAIN_PYTHON/site', '/' ])
	[<path '/Users/jab'>, <path '/Users/jab/.jab/python/site'>, <path '/'>]
 
It defaults to only the current directory
	but always returns a list
	>>> here = l.get_dirs()[0]
	>>> here
	<path '.'>

get_files
---------

get_files converts a list of directories to a list of all their files' paths
	(The list of files is flat)
	It also defaults to here
	>>> l.get_files()[0].parent.abspath() == here.abspath()
	True

So we can expect to find all of these files here
	>>> [ f in l.get_files() for f in these_files ]
	[True, True, True]

get_names
---------

This method converts a list of files to a dictionary of names
	The name of this file is 'l' (filename without extension) 
	>>> names = l.get_names()

In the current directory, there should be a few files named l
	>>> 'l' in names
	True

All the permanent paths to l:
	>>> [p for p in names['l'] if p.ext not in [ '.fail', '.pyc'] ]
	[<path 'l.py'>, <path 'l.test'>, <path 'l.tests'>]

remove_ignored
--------------

This method removes globs

The method can take a specific list of globs to be ignored
	Here's some of those for testing
	>>> sources = [ '*.c', '*.py' ]
	>>> project_managers = [ 'fred*', 'mary*' ]

It defaults to here (again) for its files
	but we'll test with these ones
	>>> files = l.as_paths([ 'fred.py', 'fred.py~', 'fred.pyc', 'mary.py', 'alan.txt'])

The default list of globs comes from ~/.subversion/config
	I usually ignore fred on the advice of Dr Mike Smith,
		so I'd normally only see alan and mary
	>>> l.remove_ignored(files)
	[<path 'mary.py'>, <path 'alan.txt'>]

But sometimes we need to ignore program managers too 
	Fred and Mary are taking program manager roles today
	>>> l.remove_ignored(files,project_managers)
	[<path 'alan.txt'>]

The globs can be used instead of the default
	What do we have apart from source code?
	>>> l.remove_ignored(files,sources)
	[<path 'fred.py~'>, <path 'fred.pyc'>, <path 'alan.txt'>]

Or the globs can be added to the default
	What do we have that's neither Fred's, nor source ?
	>>> l.remove_ignored(files,extra_ignores=sources)
	[<path 'alan.txt'>]

finding common starts paths
---------------------------

	>>> path1 = 'some/path/to/file1.py'
	>>> path2 = 'some/path/to/file2.py'
	>>> i = l.common_start(path1,path2)
	>>> print '%s | %s' % (path1[:i], path1[i:])
	some/path/to/file | 1.py
	>>> l.common_start_dirs('a/an','a/as')
	2

