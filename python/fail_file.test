The fail_file module
====================

Facilities to understand *.fail
	which are files containing doctest output

For looking at files, with line numbers
	>>> def looks_like_this(filename):
	...     for i, line in enumerate( file(filename).readlines() ):
	...         print '%2d: %s' % (i,line.rstrip())

Here's one I made earlier
	>>> test_me_text = '''Test Me
	... =======
	... \t>>> print 1
	... \t>>> print 2
	... \t3
	... \t>>> print 1 / 0
	... \t>>> print 0
	... '''


Write that out to a test file
	>>> test_me_name = 'test_me.tests'
	>>> test_me_file = file(test_me_name,'w')
	>>> test_me_file.write(test_me_text)
	>>> test_me_file.close()

Which looks like this
	>>> looks_like_this(test_me_name)
	 0: Test Me
	 1: =======
	 2: 	>>> print 1
	 3: 	>>> print 2
	 4: 	3
	 5: 	>>> print 1 / 0
	 6: 	>>> print 0

Run the test through doctest to generate some failures
	>>> test_command = 'python -c"import doctest; doctest.testfile(\'%s\')" > test_me.fail' % test_me_name
	>>> bash(test_command)
	True

Which looks like this
	>>> looks_like_this('test_me.fail')
	 0: **********************************************************************
	 1: File "test_me.tests", line 3, in test_me.tests
	 2: Failed example:
	 3:     print 1
	 4: Expected nothing
	 5: Got:
	 6:     1
	 7: **********************************************************************
	 8: File "test_me.tests", line 4, in test_me.tests
	 9: Failed example:
	10:     print 2
	11: Expected:
	12:     3
	13: Got:
	14:     2
	15: **********************************************************************
	16: File "test_me.tests", line 6, in test_me.tests
	17: Failed example:
	18:     print 1 / 0
	19: Exception raised:
	20:     Traceback (most recent call last):
	21:       File ".../doctest.py", line ..., in __run
	22:         compileflags, 1) in test.globs
	23:       File "<doctest test_me.tests[2]>", line 1, in <module>
	24:         print 1 / 0
	25:     ZeroDivisionError: integer division or modulo by zero
	26: **********************************************************************
	27: File "test_me.tests", line 7, in test_me.tests
	28: Failed example:
	29:     print 0
	30: Expected nothing
	31: Got:
	32:     0
	33: **********************************************************************
	34: 1 items had failures:
	35:    4 of   4 in test_me.tests
	36: ***Test Failed*** 4 failures.

Parse those files
	>>> from test_file import parse
	>>> tests = parse('test_me.tests')
	>>> see(tests)
	repr()    str()    .examples    .path_to_file    .sections    .source
	>>> tests
	<test_file test_me.tests>

	>>> from fail_file import read_fail_file
	>>> fail_file = read_fail_file('test_me.fail')
	>>> see( fail_file )
	repr()    .failures    .filename    .fix()
	>>> fail_file
	<FailFile 'test_me.tests'>

The test text had 4 examples, all of which were failures
	>>> 4 == len(tests.examples) == len(fail_file.failures)
	True

The line numbers were
	>>> line_numbers = [ f.line for f in fail_file.failures ]
	>>> line_numbers
	[3, 4, 6, 7]

All the fails should have a file that exists
	>>> [ f.exists() for f in fail_file.failures ]
	[True, True, True, True]

And they should all still need fixing
	>>> [ f.needed() for f in fail_file.failures ]
	[True, True, True, True]

Anyway, we call the fix method for the fail file
	>>> fail_file.fix()

And that should update the test file
	so that it now has passing tests
	>>> looks_like_this('test_me.tests')
	 0: Test Me
	 1: =======
	 2: 	>>> print 1
	 3: 	1
	 4: 	>>> print 2
	 5: 	2
	 6: 	>>> print 1 / 0
	 7: 	Traceback (most recent call last):
	 8: 	...
	 9: 	ZeroDivisionError: integer division or modulo by zero
	10: 	>>> print 0
	11: 	0

The fix method wrote out a backup file
	>>> looks_like_this('test_me.tests~')
	 0: Test Me
	 1: =======
	 2: 	>>> print 1
	 3: 	>>> print 2
	 4: 	3
	 5: 	>>> print 1 / 0
	 6: 	>>> print 0

Re-test the file, should produce no failures
	>>> bash(test_command)
	True

	>>> looks_like_this('test_me.fail')

Clean up
	>>> bash('/bin/rm test_me.*')
	True
