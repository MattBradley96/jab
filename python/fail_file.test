The fail_file module
====================

Facilities to understand *.fail
	which are files containing doctest output

	>>> from fail_file import read_fail_file

We need a test file
	>>> import doctests
	>>> doctests.write_failing_test('made_earlier.test')
	>>> doctests.try_to_pass_tests('made_earlier.test')
	False

FailFile
--------

We should now have a fail file
	There is a method to parse such a file
	>>> fail_file = read_fail_file('made_earlier.fail')

The return is an instance of FailFile
	>>> fail_file
	<FailFile 'made_earlier.fail'>

Which has some attributes
	>>> see( fail_file )
	repr()    .failures    .path_to_fail

Including the file it was read from
	>>> print fail_file.path_to_fail
	made_earlier.fail

The test text had 4 examples, all of which were failures
	>>> 4 == len(fail_file.failures)
	True

Failure
-------

Taking the third one
	>>> failure = fail_file.failures[2]

It has attributes
	>>> spread(failure)
	<fail_file.Failure
		path_to_test : 'made_earlier.test'
		actual : ['Traceback (most recent call last):',
		 '...',
		 'ZeroDivisionError: integer division or modulo by zero']
		expected : ''
		test_line_number : 6
		example : 'print 1 / 0'
		fail_line_number : 16
	>

Including the file that failure occurred in, and the line number
	>>> print '%s at %s' % ( failure.path_to_test, failure.test_line_number )
	made_earlier.test at 6

As well as the expected and actual data (lists of lines for both)
	>>> print '\n'.join(failure.expected)

	>>> print '\n'.join(failure.actual)
	Traceback (most recent call last):
	...
	ZeroDivisionError: integer division or modulo by zero

Is that failure still there ?
	>>> failure.exists()
	True

Cleanup
=======
	>>> import commands
	>>> '' == commands.getoutput('rm -rf made_earlier.*')
	True
