The sis module
==============

Is a companion to sys
	>>> import sis

paths
-----

For example, sys.path is a list of strings
	>>> sys.path[-1]
	'/System/Library/Frameworks/Python.framework/Versions/2.5/Extras/lib/python/PyObjC'

Wonder who added that path('.') at the start ?
Anyway,
	sis module also has path,
		but every item in the list is a path

	>>> sis.path[-1]
	Traceback (most recent call last):
	...
	AttributeError: 'module' object has no attribute 'path'

Ooops, silly me, if it is a list, then it should be called paths
	>>> sis.paths[-1]
	<path '/System/Library/Frameworks/Python.framework/Versions/2.5/Extras/lib/python/PyObjC'>

The two attributes are not kept in sync
	>>> sys.path[-1] == str(sis.paths[-1])
	True
	>>> sys.path.append('/usr/local/lib')
	>>> sys.path[-1] == str(sis.paths[-1])
	False

So, if you change sys.path, call this
	>>> sis.sys_path()
	>>> sys.path[-1] == str(sis.paths[-1])
	True
	>>> del sys.path[-1]
	>>> sys.path[-1] == str(sis.paths[-1])
	False
	>>> sis.sys_path()
	>>> sys.path[-1] == str(sis.paths[-1])
	True

Filtering path
--------------

A method to filter out any site-packages directory
	(will include sub-directories)
	>>> all( [ 'site-packages' in p.splitall()  for p in sis.sites() ] )
	True

You could supply your own list of paths to filter
	the default is sis.paths
	>>> sis.sites(sis.paths) == sis.sites()
	True
	
And a method to filter out directories whose name is site_packages
	(will not include sub-directories)
	which also defaults to sis.paths
	>>> all( [ p.name == 'site-packages' for p in sis.site_packages() ] )
	True
