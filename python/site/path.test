The path module
===============

Using the Path class
--------------------

This file is to show examples of usage of the Path class
This class extends the path class in the same module, but that is not tested

First import the classes and methods
	
	>>> import path

We'll need the os module for some of the tests below

	>>> import os
	>>> startHere = os.getcwd()

The pwd() method is a synonym for os.getcwd()

	>>> path.pwd == os.getcwd and path.pwd() == startHere
	True

The cd() method (at least) calls os.chdir()
It returns True if the change of directory is successful

	>>> path.pwd() == '/usr/lib'
	False
	>>> path.cd('/usr/lib')
	True
	>>> path.pwd() == '/usr/lib'
	True
	>>> path.cd('/no/such/path')
	False
	>>> path.pwd() == '/usr/lib'
	True

cd() recognises the special value '-' to go back to the previous directory
	(which ignores the /no/such/path error)

	>>> path.cd('-') and path.pwd() == startHere or 'fail'
	True

Calling using '-' repeatedly will toggle between two directories:

	>>> path.cd('/usr')
	True
	>>> path.cd('/home')
	True
	>>> for i in range(0,9):
	...    _ = path.cd('-')
	...    print path.pwd(),
	/usr /home /usr /home /usr /home /usr /home /usr

If the path to a file is given, cd() will change to that file's parent directory

	>>> passwd = path.makepath('/etc/passwd')
	>>> path.cd(passwd)
	True
	>>> path.pwd() == passwd.parent
	True

Path
----

A class called Path is also supplied, which extends the path class, slightly.
You can construct an instance of Path directly:

	>>> p = path.Path('.')

Or by using the method makepath

	>>> p = path.makepath('.')

The difference is that makepath expands the string given

	>>> print path.Path('~/..')
	~/..
	>>> print path.makepath('~/..')
	/Users

Path is ako string, which shows the string in %s and %r

	>>> bin = path.Path('/bin')
	>>> print '%s' % bin
	/bin
	>>> print '%r' % bin
	<Path '/bin'>

Path has a pwd() method
	which is just a synonym for the method of the same name at module level

	>>> p.pwd == os.getcwd and path.pwd() == p.pwd()
	True

Path adds the cd() method, which cd's to the path it represents
It calls the module level cd() method with its own value, so it works as above.

	>>> passwd.cd()
	True
	>>> path.pwd() == passwd.parent
	True

There are also path.pushd() and path.popd() in the module
	which are similar to their synonyms from bash

path.pushd() puts the current directory onto the stack
	then cd's to that directory
path.popd() takes the top from the stack
	then cd's to that directory
	>>> path.cd('/usr') and path.pwd() or 'fail'
	'/usr'
	>>> path.pushd('/var') and path.pwd() or 'fail'
	'/private/var'
	>>> path.pushd('/bin') and path.pwd() or 'fail'
	'/bin'
	>>> path.cd('/') and path.pwd() or 'fail'
	'/'
	>>> print path.dirStack
	['/usr', '/private/var']
	>>> path.popd() and path.pwd() or 'fail'
	'/private/var'
	>>> path.popd() and path.pwd() or 'fail'
	'/usr'

Path vs path
------------

Using the / operator on a Path or path gives an instance of the same class
	>>> home = path.path('~')
	>>> bashrc = home / '.bashrc'
	>>> type(bashrc)
	<class 'path.path'>

	>>> home = path.Path('~')
	>>> bashrc = home / '.bashrc'
	>>> type(bashrc)
	<class 'path.Path'>

Attributes of a Path should also be Paths (should not be path)
	>>> type(bashrc.parent)
	<class 'path.Path'>

The split_all_ext method
------------------------

	>>> p = path.Path('/alan/was/here.tar.gz')
	>>> p.splitext()
	(<Path '/alan/was/here.tar'>, '.gz')
	>>> p.split_all_ext()
	(<Path '/alan/was/here'>, '.tar.gz')

The ancestor method
-------------------

	>>> path.cd(startHere)
	True
	>>> p = path.makepath('./path.test')

The ancestor method finds a directory in the path
	>>> print path.ancestor(p,'python').parent.name
	.jab

It matches on regexps
	>>> source = 'p[ytho]*n'
	>>> print path.ancestor(p,source).parent.name
	.jab

It finds the lowest available match
	(This is only tested fully where user is jab too)
	>>> jabs = '.*jab'
	>>> print path.ancestor(p,jabs).name
	.jab

An ancestor is not its own ancestor
	>>> print path.ancestor(path.ancestor(p,jabs),jabs).name
	jab

It gives nothing if not found
	>>> print path.ancestor(p,'Source')
	None

sub_dirs
--------

This method extends dirs() to include all sub directories
	>>> bash('mkdir -p ~/x ~/x/one ~/x/one/one ~/x/one/two ~/x/two ~/x/two/two')
	True
	>>> p = path.makepath('~/x')

The standard method calls os.listdir
	>>> print p.dirs()
	[<Path '/Users/jab/x/one'>, <Path '/Users/jab/x/two'>]

sub_dirs() uses walkdirs instead
	>>> show( p.sub_dirs() )
	[<Path '/Users/jab/x/one'>,
	 <Path '/Users/jab/x/one/one'>,
	 <Path '/Users/jab/x/one/two'>,
	 <Path '/Users/jab/x/two'>,
	 <Path '/Users/jab/x/two/two'>]

all_dirs() adds the directory itself
	>>> show( p.all_dirs() )
	[<Path '/Users/jab/x'>,
	 <Path '/Users/jab/x/one'>,
	 <Path '/Users/jab/x/one/one'>,
	 <Path '/Users/jab/x/one/two'>,
	 <Path '/Users/jab/x/two'>,
	 <Path '/Users/jab/x/two/two'>]


If given a file these methods use its parent directory
	>>> p = path.makepath('~/x/fred')
	>>> show( p.all_dirs() )
	[<Path '/Users/jab/x'>,
	 <Path '/Users/jab/x/one'>,
	 <Path '/Users/jab/x/one/one'>,
	 <Path '/Users/jab/x/one/two'>,
	 <Path '/Users/jab/x/two'>,
	 <Path '/Users/jab/x/two/two'>]

The module-level dirs() method gives a recursive list
	with list-in-list corresponging to dir-in-dir
	>>> show( path.dirs(p) )
	(<Path '/Users/jab/x'>, [['one', [['one'], ['two']]], ['two', [['two']]]])

	>>> def show(indent,x):
	...     print '%s%s' % (indent,x[0])
	...     if len(x) > 1:
	...         for y in x[1]:
	...             show(indent+'\t',y)
	>>> show( '',  path.dirs(p) )
	/Users/jab/x
		one
			one
			two
		two
			two
	>>> bash('rm -rf ~/x')
	True

Simplified path
---------------

	>>> p
	<Path '/Users/jab/x/fred'>
	>>> p.from_home()
	<Path 'x/fred'>
